<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>axum notes</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="notes/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="notes/basic/index.html"><strong aria-hidden="true">2.</strong> Basic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="notes/basic/offloading_computation/index.html"><strong aria-hidden="true">2.1.</strong> Offloading computation</a></li></ol></li><li class="chapter-item expanded "><a href="notes/templating/index.html"><strong aria-hidden="true">3.</strong> Templating</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="notes/templating/with_askama/index.html"><strong aria-hidden="true">3.1.</strong> Using askama</a></li></ol></li><li class="chapter-item expanded "><a href="notes/db/index.html"><strong aria-hidden="true">4.</strong> Databases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="notes/db/with_sqlx/index.html"><strong aria-hidden="true">4.1.</strong> Using SQLx</a></li><li class="chapter-item expanded "><a href="notes/db/with_sqlx_tx/index.html"><strong aria-hidden="true">4.2.</strong> Using axum-sqlx-tx</a></li></ol></li><li class="chapter-item expanded "><a href="notes/auth/index.html"><strong aria-hidden="true">5.</strong> Authorization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="notes/auth/with_tower_http/index.html"><strong aria-hidden="true">5.1.</strong> Using tower-http</a></li></ol></li><li class="chapter-item expanded "><a href="notes/misc/index.html"><strong aria-hidden="true">6.</strong> Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="notes/misc/serve_static_from_binary/index.html"><strong aria-hidden="true">6.1.</strong> Serve data from binary</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">axum notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/matze/axum-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/tokio-rs/axum">axum</a> is a web framework to implement HTTP servers. It is to Rust what Flask is to Python which
means a toolbox rather than a ready-made shed.</p>
<p>These notes give you examples how to approach common tasks either directly with axum or
best-in-class third-party dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="handling-ctrl-c-gracefully"><a class="header" href="#handling-ctrl-c-gracefully">Handling Ctrl-C gracefully</a></h2>
<p>axum re-exports hyper's <a href="https://docs.rs/hyper/latest/hyper/server/struct.Server.html">Server</a> which provides the <a href="https://docs.rs/hyper/latest/hyper/server/struct.Server.html#method.with_graceful_shutdown">with_graceful_shutdown</a>
method that is easily combined with tokio's <a href="https://docs.rs/tokio/latest/tokio/signal/fn.ctrl_c.html">signal::ctrl_c</a> function
(available under the <code>signal</code> feature flag):</p>
<pre><code class="language-rust  noplayground">axum::Server::bind(&amp;addr)
    .serve(app.into_make_service())
    .with_graceful_shutdown(async {
        tokio::signal::ctrl_c().await.expect(&quot;failed to listen to ctrl-c&quot;);
    })
    .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="offloading-computation"><a class="header" href="#offloading-computation">Offloading computation</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
axum = { version = &quot;0.5&quot; }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-rust noplayground">use axum::extract::{Extension, Path};
use axum::response::Json;
use axum::routing::get;
use tokio::sync::{mpsc, oneshot};

// Commands send to the processor. We use the oneshot sender to &quot;call back&quot; to the peer who send us
// the command.
enum Command {
    Sleep {
        secs: u64,
        // Using oneshot::Sender&lt;Result&lt;_&gt;&gt; we can propagate errors back to the caller
        tx: oneshot::Sender&lt;Result&lt;u64, ()&gt;&gt;,
    },
}

async fn process_compute_request(mut rx: mpsc::Receiver&lt;Command&gt;) {
    // Note, that this serializes incoming requests. If you want to handle requests in parallel,
    // you have to spawn tasks once more.
    while let Some(command) = rx.recv().await {
        match command {
            Command::Sleep { secs, tx } =&gt; {
                let _ = tx.send(Ok(secs + 23));
            }
        }
    }
}

async fn compute_complex(
    Path(secs): Path&lt;u64&gt;,
    Extension(command_tx): Extension&lt;mpsc::Sender&lt;Command&gt;&gt;,
) -&gt; Json&lt;u64&gt; {
    // Construct a oneshot channel to receive the result from the processor.
    let (tx, rx) = oneshot::channel();

    // Send the command carrying the payload as well as the result sender.
    let _ = command_tx.send(Command::Sleep { secs, tx }).await;

    // Wait for the result to be returned by the processor.
    let result = rx.await.unwrap().unwrap();

    Json(result)
}

async fn compute_simple(Path(secs): Path&lt;u64&gt;) -&gt; Json&lt;u64&gt; {
    println!(&quot;asked to sleep for {secs} secs&quot;);

    // Spawn an async task on a separate thread to avoid blocking the async run-time.
    let result = tokio::task::spawn_blocking(move || {
        // Unlike tokio::time::sleep, this one blocks the current thread.
        std::thread::sleep(std::time::Duration::from_secs(secs));
        secs + 42
    })
    .await
    .unwrap();

    println!(&quot;returned after {secs} secs&quot;);

    Json(result)
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let (tx, rx) = mpsc::channel(128);

    let app = axum::Router::new()
        .route(&quot;/compute/simple/:secs&quot;, get(compute_simple))
        .route(&quot;/compute/complex/:secs&quot;, get(compute_complex))
        .layer(Extension(tx));

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], 3000));

    let server = tokio::task::spawn(async move {
        axum::Server::bind(&amp;addr)
            .serve(app.into_make_service())
            .await
            .unwrap();
    });

    let processor = tokio::task::spawn(async move {
        process_compute_request(rx).await;
    });

    let (_, _) = tokio::join!(server, processor);

    Ok(())
}
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>Start the server with</p>
<pre><code>cargo run --bin offloading_computation
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="templating-using-askama"><a class="header" href="#templating-using-askama">Templating using askama</a></h1>
<p><a href="https://docs.rs/askama/latest/askama/">Askama</a> implements a type-safe, Jinja-like template engine. While the templating engine itself
is independent of any particular application, the <code>askama_axum</code> crate provides additional
integration points by converting template results to response objects. Because Askama evaluates
templates at compile time, it is both safe to use and fast to evaluate. On the other hand, it
cannot be fed with templates by users at run-time.</p>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
askama = { git = &quot;https://github.com/djc/askama&quot;, features = [&quot;with-axum&quot;] }
askama_axum = { git = &quot;https://github.com/djc/askama&quot; }
axum = &quot;0.5&quot;
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<p>First create a new sibling directory <code>templates</code> next to the <code>src</code> directory and add an
<code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Askama&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;p&gt;Hello {{ name }}, you are {{ age }} years old.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Note that we refer to the two template variables <code>name</code> and <code>age</code>. Thanks to the compile-time
guarantees of askama, the compiler will complain if we do not derive a template that contains these
variables:</p>
<pre><code class="language-rust noplayground">use askama::Template;
use axum::extract::Path;
use axum::routing::get;
use axum::Server;

#[derive(Template)]
#[template(path = &quot;index.html&quot;)]
struct HtmlTemplate {
    name: String,
    age: u8,
}

async fn index(Path((name, age)): Path&lt;(String, u8)&gt;) -&gt; HtmlTemplate {
    HtmlTemplate { name, age }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = axum::Router::new().route(&quot;/:name/:age&quot;, get(index));

    Server::bind(&amp;&quot;0.0.0.0:8080&quot;.parse()?)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
</code></pre>
<h2 id="run-1"><a class="header" href="#run-1">Run</a></h2>
<p>Start the server with</p>
<pre><code>cargo run --bin templating-with-askama
</code></pre>
<p>Now, lets try to get <code>/john/32</code>:</p>
<pre><code>$ curl -i http://127.0.0.1:8080/john/32
HTTP/1.1 200 OK
content-type: text/html; charset=utf-8
content-length: 167
date: Tue, 08 Mar 2022 20:13:10 GMT

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Askama&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;p&gt;Hello john, you are 32 years old.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="database-access-with-sqlx"><a class="header" href="#database-access-with-sqlx">Database access with SQLx</a></h1>
<p><a href="https://docs.rs/crate/sqlx/latest">SQLx</a> is an async-first SQL crate to access various SQL databases. While
compile-time verification of queries is one of the outstanding features, we will
use ordinary queries here to show how to use it together with axum.</p>
<h2 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
axum = { version = &quot;0&quot; }
serde = &quot;1&quot;
serde_json = &quot;1&quot;
sqlx = { version = &quot;0.5&quot;, features = [&quot;runtime-tokio-rustls&quot;, &quot;sqlite&quot;, &quot;macros&quot;] }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<p>In this example, we will implement a super simple blog backend, consisting of
posts with a title and some content string. We accept two routes <code>/api/post</code> and
<code>/api/posts/</code>, the latter used to query all existing posts and to add a new one.</p>
<p>As usual, import some used modules first:</p>
<pre><code class="language-rust noplayground">use axum::extract::{Extension, Path};
use axum::response::Json;
use axum::routing::get;
use serde::{Deserialize, Serialize};
use sqlx::sqlite::{SqliteConnectOptions, SqlitePool, SqlitePoolOptions};
use sqlx::{ConnectOptions, FromRow};
use std::str::FromStr;
use std::sync::Arc;
</code></pre>
<p>Now, we define a small helper struct that keeps the connection pool alive as
well as an implementation to set up the (in-memory SQLite) database:</p>
<pre><code class="language-rust noplayground">/// Database object encapsulating the connection pool and providing convenience functions.
struct Database {
    pool: SqlitePool,
}

impl Database {
    pub async fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let db_options = SqliteConnectOptions::from_str(&quot;:memory:&quot;)?
            .create_if_missing(true)
            .disable_statement_logging()
            .to_owned();

        let pool = SqlitePoolOptions::new().connect_with(db_options).await?;

        sqlx::query(
            &quot;CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY,
                title TEXT NOT NULL,
                content NOT NULL
            );&quot;,
        )
        .execute(&amp;pool)
        .await?;

        Ok(Self { pool })
    }
}
</code></pre>
<p>Let's define a struct to represent a post and add the handlers to insert and
query posts:</p>
<pre><code class="language-rust noplayground">#[derive(FromRow, Serialize, Deserialize)]
struct Post {
    title: String,
    content: String,
}

async fn get_post(Path(id): Path&lt;i64&gt;, Extension(db): Extension&lt;Arc&lt;Database&gt;&gt;) -&gt; Json&lt;Post&gt; {
    Json(
        sqlx::query_as::&lt;_, Post&gt;(&quot;SELECT title, content FROM posts WHERE id=?&quot;)
            .bind(id)
            .fetch_one(&amp;db.pool)
            .await
            .unwrap(),
    )
}

async fn add_post(Extension(db): Extension&lt;Arc&lt;Database&gt;&gt;, Json(post): Json&lt;Post&gt;) {
    sqlx::query(&quot;INSERT INTO posts (title, content) VALUES (?, ?);&quot;)
        .bind(post.title)
        .bind(post.content)
        .execute(&amp;db.pool)
        .await
        .unwrap();
}

async fn posts(Extension(db): Extension&lt;Arc&lt;Database&gt;&gt;) -&gt; Json&lt;Vec&lt;Post&gt;&gt; {
    Json(
        sqlx::query_as::&lt;_, Post&gt;(&quot;SELECT title, content FROM posts&quot;)
            .fetch_all(&amp;db.pool)
            .await
            .unwrap(),
    )
}
</code></pre>
<p>As you can see we can re-use the same struct (and benefit from type-safety
guarantees) for both serialization and deserialization in the database
as well as for sending and receiving posts to and from the client by deriving
the appropriate traits.</p>
<p>All that's left is setting up the server itself:</p>
<pre><code class="language-rust noplayground">#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let state = Arc::new(Database::new().await?);

    let app = axum::Router::new()
        .route(&quot;/api/posts&quot;, get(posts).post(add_post))
        .route(&quot;/api/posts/:id&quot;, get(get_post))
        .layer(Extension(state));

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], 3000));

    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
</code></pre>
<h2 id="run-2"><a class="header" href="#run-2">Run</a></h2>
<p>Start the server with</p>
<pre><code>cargo run --bin with-sqlx
</code></pre>
<p>and add posts with</p>
<pre><code>curl -X POST -H 'Content-Type: application/json' -d '{&quot;title&quot;: &quot;Hello&quot;, &quot;content&quot;: &quot;World&quot;}' http://127.0.0.1:3000/api/posts
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-access-with-axum-sqlx-tx"><a class="header" href="#database-access-with-axum-sqlx-tx">Database access with axum-sqlx-tx</a></h1>
<p><a href="https://docs.rs/axum-sqlx-tx/latest/axum_sqlx_tx/">axum-sqlx-tx</a> is an alternative, layer-based approach to using SQLx directly.
One big advantage is that transactions are committed or rolled back
automatically if any of the inner requests succeed or return an error.</p>
<h2 id="dependencies-3"><a class="header" href="#dependencies-3">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
axum = { version = &quot;0.5&quot; }
axum-sqlx-tx = { git = &quot;https://github.com/wasdacraic/axum-sqlx-tx&quot;, features = [&quot;sqlite&quot;] }
serde = &quot;1&quot;
serde_json = &quot;1&quot;
sqlx = { version = &quot;0.5&quot;, features = [&quot;runtime-tokio-rustls&quot;, &quot;sqlite&quot;, &quot;macros&quot;] }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<p>Unlike before, we do not have to manage the SQL pool in an <code>std::Arc&lt;&gt;</code>
ourselves, hence it is enough to just create the pool</p>
<pre><code class="language-rust noplayground">async fn new_pool() -&gt; Result&lt;SqlitePool, Box&lt;dyn std::error::Error&gt;&gt; {
    let db_options = SqliteConnectOptions::from_str(&quot;:memory:&quot;)?
        .create_if_missing(true)
        .disable_statement_logging()
        .to_owned();

    let pool = SqlitePoolOptions::new().connect_with(db_options).await?;

    sqlx::query(
        &quot;CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY,
            title TEXT NOT NULL,
            content NOT NULL
        );&quot;,
    )
    .execute(&amp;pool)
    .await?;

    Ok(pool)
}
</code></pre>
<p>and add the layer to the routes:</p>
<pre><code class="language-rust noplayground">#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = axum::Router::new()
        .route(&quot;/api/posts&quot;, get(posts).post(add_post))
        .route(&quot;/api/posts/:id&quot;, get(get_post))
        .layer(axum_sqlx_tx::Layer::new(new_pool().await?));

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], 3000));

    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
</code></pre>
<p>Because the <code>Tx</code> type implements sqlx' executor interface, all we need to change
is the type of the parameter:</p>
<pre><code class="language-rust noplayground">async fn get_post(Path(id): Path&lt;i64&gt;, mut tx: Tx&lt;Sqlite&gt;) -&gt; Json&lt;Post&gt; {
    Json(
        sqlx::query_as::&lt;_, Post&gt;(&quot;SELECT title, content FROM posts WHERE id=?&quot;)
            .bind(id)
            .fetch_one(&amp;mut tx)
            .await
            .unwrap(),
    )
}

async fn add_post(mut tx: Tx&lt;Sqlite&gt;, Json(post): Json&lt;Post&gt;) {
    sqlx::query(&quot;INSERT INTO posts (title, content) VALUES (?, ?);&quot;)
        .bind(post.title)
        .bind(post.content)
        .execute(&amp;mut tx)
        .await
        .unwrap();
}

async fn posts(mut tx: Tx&lt;Sqlite&gt;) -&gt; Json&lt;Vec&lt;Post&gt;&gt; {
    Json(
        sqlx::query_as::&lt;_, Post&gt;(&quot;SELECT title, content FROM posts&quot;)
            .fetch_all(&amp;mut tx)
            .await
            .unwrap(),
    )
}
</code></pre>
<h2 id="run-3"><a class="header" href="#run-3">Run</a></h2>
<p>Start the server with</p>
<pre><code>cargo run --bin with-sqlx-tx
</code></pre>
<p>and add posts with</p>
<pre><code>curl -X POST -H 'Content-Type: application/json' -d '{&quot;title&quot;: &quot;Hello&quot;, &quot;content&quot;: &quot;World&quot;}' http://127.0.0.1:3000/api/posts
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-using-tower-http"><a class="header" href="#authorization-using-tower-http">Authorization using tower-http</a></h1>
<p>In this example we will use tower-http's <a href="https://docs.rs/tower-http/latest/tower_http/auth/index.html">auth module</a> to add a <a href="https://docs.rs/tower-http/latest/tower_http/auth/struct.RequireAuthorizationLayer.html#method.custom">custom</a>
authorization layer. There are also two builtin <code>bearer</code> and <code>password</code> layers
however since both bearer token and username and password combo are set at
compile time, the use is somewhat limited.</p>
<p>In this case we implement the <code>AuthorizeRequest</code> trait for our custom <code>Auth</code>
struct, which requires to set the appropriate <code>ResponseBody</code> (which in axum's
case <em>must be</em> <code>axum::body::BoxBody</code>) as well as an <code>authorize</code> method. Here,
based on the request and any data on the struct itself we can make authorization
decisions. In this example we extract the <code>Authorization</code> header field and
compare it with a pre-defined value. If it matches we can return <code>Ok(())</code> and
the route is taken otherwise we return an error response.</p>
<h2 id="dependencies-4"><a class="header" href="#dependencies-4">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
axum = &quot;0.5&quot;
tower-http = { version = &quot;0.2&quot;, features = [&quot;auth&quot;] }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<pre><code class="language-rust noplayground">use axum::body::BoxBody;
use axum::http::{header, Request, StatusCode};
use axum::response::Response;
use axum::routing::get;
use axum::{Router, Server};
use tower_http::auth::{AuthorizeRequest, RequireAuthorizationLayer};

#[derive(Clone)]
struct Auth {
    expected: String,
}

impl&lt;B&gt; AuthorizeRequest&lt;B&gt; for Auth {
    type ResponseBody = BoxBody;

    fn authorize(&amp;mut self, request: &amp;mut Request&lt;B&gt;) -&gt; Result&lt;(), Response&lt;Self::ResponseBody&gt;&gt; {
        if let Some(header) = request.headers().get(header::AUTHORIZATION) {
            if header == &amp;self.expected {
                return Ok(());
            }
        }

        let response = Response::builder()
            .status(StatusCode::UNAUTHORIZED)
            .body(BoxBody::default())
            .unwrap();

        Err(response)
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Router::new().route(&quot;/&quot;, get(|| async { &quot;hello&quot; })).layer(
        RequireAuthorizationLayer::custom(Auth {
            expected: &quot;lol&quot;.to_string(),
        }),
    );

    Server::bind(&amp;&quot;0.0.0.0:8080&quot;.parse()?)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
</code></pre>
<h2 id="run-4"><a class="header" href="#run-4">Run</a></h2>
<p>Start the server with</p>
<pre><code>cargo run --bin auth-with-tower-http
</code></pre>
<p>Trying to get the root route without setting an authorization header results in
a 401:</p>
<pre><code>$ curl -i http://127.0.0.1:8080
HTTP/1.1 401 Unauthorized
content-length: 0
date: Tue, 08 Mar 2022 19:57:15 GMT
</code></pre>
<p>On the other hand, setting <code>Authorization</code> appropriately succeeds:</p>
<pre><code>$ curl -i -H &quot;Authorization: lol&quot; http://127.0.0.1:8080
HTTP/1.1 200 OK
content-type: text/plain; charset=utf-8
content-length: 5
date: Tue, 08 Mar 2022 19:59:15 GMT

hello
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="serve-static-data-from-the-binary"><a class="header" href="#serve-static-data-from-the-binary">Serve static data from the binary</a></h1>
<p>For very small (micro) services it can come in handy to just distribute a single
binary containing both code and data such as CSS or Javascript and avoid the
hassle of dealing with paths, permissions, deployment etc. In this example we
use the handy <a href="https://crates.io/crates/include_dir">include_dir</a> crate to bundle a directory of data within the
compiled binary and the <a href="https://crates.io/crates/mime_guess">mime_guess</a> crate to guess a MIME type based on the
served file.</p>
<h2 id="dependencies-5"><a class="header" href="#dependencies-5">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
axum = &quot;0.5&quot;
include_dir = &quot;0&quot;
mime_guess = &quot;2&quot;
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="code-5"><a class="header" href="#code-5">Code</a></h2>
<p>First of all create a <code>static</code> directory next to the <code>src</code> directory and add
this sample CSS file <code>foo.css</code>:</p>
<pre><code class="language-css">body {
    background-color: #ccc;
}
</code></pre>
<p>The interesting part of the code are the route which matches <em>any</em> path prefixed
<code>/static</code> and the handler. In the handler we first strip the initial slash
(because that would not match with <code>get_file</code>) and then just try to load the
file. If we have a match, we try to guess a suitable MIME type and return it,
otherwise we just return a 404:</p>
<pre><code class="language-rust noplayground">use axum::body::{self, Empty, Full};
use axum::extract::Path;
use axum::http::{header, HeaderValue, StatusCode};
use axum::response::{IntoResponse, Response};
use axum::routing::get;
use axum::{Router, Server};
use include_dir::{include_dir, Dir};

static STATIC_DIR: Dir&lt;'_&gt; = include_dir!(&quot;$CARGO_MANIFEST_DIR/static&quot;);

async fn static_path(Path(path): Path&lt;String&gt;) -&gt; impl IntoResponse {
    let path = path.trim_start_matches('/');
    let mime_type = mime_guess::from_path(path).first_or_text_plain();

    match STATIC_DIR.get_file(path) {
        None =&gt; Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(body::boxed(Empty::new()))
            .unwrap(),
        Some(file) =&gt; Response::builder()
            .status(StatusCode::OK)
            .header(
                header::CONTENT_TYPE,
                HeaderValue::from_str(mime_type.as_ref()).unwrap(),
            )
            .body(body::boxed(Full::from(file.contents())))
            .unwrap(),
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Router::new().route(&quot;/static/*path&quot;, get(static_path));

    Server::bind(&amp;&quot;0.0.0.0:8080&quot;.parse()?)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
</code></pre>
<h2 id="run-5"><a class="header" href="#run-5">Run</a></h2>
<p>Start the server with</p>
<pre><code>cargo run --bin serve-static-from-binary
</code></pre>
<p>and it will serve <code>/static/foo.css</code> as expected</p>
<pre><code>$ curl http://127.0.0.1:8080/static/foo.css
body {
    background-color: #ccc;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
